#version 430

// Model/view/projection matrix
layout(location = 0) uniform mat4 mvp;
layout(location = 2) uniform vec3 view_pos;
layout(location = 3) uniform float time;
layout(location = 4) uniform float gridWidth;
layout(location = 5) uniform float gridHeight;

// Per-vertex attributes
layout(location = 0) in vec3 pos; // World-space position

#define M_PI 3.1415926535897932384626433832795

out vec3 fragPos;
out vec3 fragNormal;

//
//          neigh2
//  neigh3  -   x   -   neigh1
//          neigh4
//
vec3 calculateNormal(vec3 edge1,vec3 edge2)
{
    return normalize(cross(edge1,edge2));
}

void main(void) {
    view_pos;
    float waveCount = 50;
    float waveSpeed = 5;
    float waveHeight = 0.01;
    vec3 neigh1  = vec3(pos.x + gridWidth,pos.y,(cos((pos.x + gridWidth) * waveCount + time* waveSpeed) + sin(pos.y * waveCount + time * waveSpeed)) * waveHeight);
    vec3 neigh2  = vec3(pos.x , pos.y + gridHeight,(cos(pos.x * waveCount + time* waveSpeed) + sin((pos.y + gridHeight) * waveCount + time * waveSpeed)) * waveHeight);
    vec3 neigh3  = vec3(pos.x - gridWidth,pos.y,((cos(pos.x - gridWidth) * waveCount + time* waveSpeed) + sin(pos.y * waveCount + time * waveSpeed)) * waveHeight);
    vec3 neigh4  = vec3(pos.x , pos.y - gridHeight,(cos(pos.x * waveCount + time* waveSpeed) + sin((pos.y - gridHeight) * waveCount + time * waveSpeed)) * waveHeight);
    
    vec3 accumNormal = (calculateNormal(neigh1 - pos, neigh2 - pos) + 
                        calculateNormal(neigh2 - pos, neigh3 - pos) + 
                        calculateNormal(neigh3 - pos, neigh4 - pos) + 
                        calculateNormal(neigh4 - pos, neigh1 - pos));

    fragNormal = normalize(accumNormal);
    
    fragPos = vec3(pos.x,pos.y, (cos(pos.x * waveCount + time* waveSpeed) + sin(pos.y * waveCount + time * waveSpeed)) * waveHeight);
    gl_Position = mvp * vec4(fragPos,1.);
}